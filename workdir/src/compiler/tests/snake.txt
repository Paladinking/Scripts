struct COORD {
    int16 x;
    int16 y;
}

struct KEY_EVENT_RECORD {
    uint32 bKeyDown;
    uint16 wRepeatCount;
    uint16 wVirtualKeyCode;
    uint16 wVirtualScanCode;
    uint16 UnicodeChar;
    uint32 dwControlKeyState;
}

struct INPUT_RECORD {
    uint16 EventType;
    KEY_EVENT_RECORD key;
}

extern fn GetTickCount() -> uint32;
extern fn GetConsoleMode(uint64 h, uint32* mode) -> uint32;
extern fn SetConsoleMode(uint64 h, uint32 mode) -> uint32;
extern fn GetNumberOfConsoleInputEvents(uint64 h, uint32* count) -> uint32;
extern fn ReadConsoleInputW(uint64 h, INPUT_RECORD* buf, uint32 len, uint32* read) -> uint32;
extern fn SetConsoleCursorPosition(uint64 h, COORD c) -> uint32;
extern fn WriteConsoleW(uint64 h, uint8* b, uint32 to_write, uint32* w, uint8* reserverd) -> uint32;
extern fn GetStdHandle(uint32 h) -> uint64;
extern fn Sleep(uint32 ms);

struct Part {
    uint32 x;
    uint32 y;
}

fn has_snake(Part* snake, uint32 len, uint32 x, uint32 y) -> bool {
    uint32 ix = 0;
    while (ix < len) {
        if (snake[ix].x == x && snake[ix].y == y) {
            return true;
        }

        ix = ix + 1;
    }
    return false;
}

fn output(Part* snake, uint32 len, uint32 ax, uint32 ay) {
    uint64 h = GetStdHandle(-11);

    COORD c;
    c.x = 0;
    c.y = 0;

    SetConsoleCursorPosition(h, c);

    uint8* filled = "\x88\x25\x88\x25";
    uint8* empty = " \x00 \x00";
    uint8* shaded = "\x92\x25\x92\x25";
    uint8* shadeded = "\x93\x25\x93\x25";

    uint32 w;
    uint8[2550] buf;
    uint64 ix = 0;

    uint64 y = 0;
    while (y < 25) {
        uint64 x = 0;
        while (x < 25) {
            uint8* ptr = empty;
            if (x == 0 || y == 0 || x == 24 || y == 24) {
                ptr = filled;
            } else if (has_snake(snake, len, x, y)) {
                ptr = shaded;
            } else if (x == ax && y == ay) {
                ptr = shadeded;
            }

            buf[ix] = ptr[0];
            buf[ix + 1] = ptr[1];
            buf[ix + 2] = ptr[2];
            buf[ix + 3] = ptr[3];
            ix = ix + 4;
            x = x + 1;
        }
        uint8* newline = "\n\x00";
        buf[ix] = newline[0];
        ix = ix + 1;
        buf[ix] = newline[1];
        ix = ix + 1;
        y = y + 1;
    }
    WriteConsoleW(h, buf, ix / 2, &w, null);
}

fn randomize_apple(uint32* x, uint32* y, Part* snake, uint32 len) -> uint32 {
    while (true) {
        uint32 random = (GetTickCount() * 1103515245 + 12345);
        *x = (random % 23) + 1;
        *y = ((random >> 8) % 23) + 1;
        if (!has_snake(snake, len, *x, *y)) {
            return 0;
        }
    }
}

fn main() -> uint64 {
    Part[256] snake;
    uint32 ix = 0;
    while (ix < 50) {
        snake[ix].x = 12;
        snake[ix].y = 12;

        ix = ix + 1;
    }
    uint64 h = GetStdHandle(-10);

    uint32 old_mode;
    GetConsoleMode(h, &old_mode);

    SetConsoleMode(h, 0x1);

    int32 dx = 1;
    int32 dy = 0;

    uint32 len = 10;

    uint32 ax;
    uint32 ay;
    randomize_apple(&ax, &ay, snake, len);

    while (true) {
        uint32 evt_count;
        GetNumberOfConsoleInputEvents(h, &evt_count);
        uint32 ndx = dx;
        uint32 ndy = dy;
        while (evt_count > 0) {
            INPUT_RECORD i;
            ReadConsoleInputW(h, &i, 1, &evt_count);
            if (i.EventType == 1 && i.key.bKeyDown != 0) {
                if (i.key.wVirtualKeyCode == 67) {
                    SetConsoleMode(h, old_mode);
                    return 0;
                }
                if (i.key.wVirtualKeyCode == 65) {
                    if (dx == 0) {
                        ndy = 0;
                        ndx = -1;
                    }
                } else if (i.key.wVirtualKeyCode == 68) {
                    if (dx == 0) {
                        ndy = 0;
                        ndx = 1;
                    }
                } else if (i.key.wVirtualKeyCode == 83) {
                    if (dy == 0) {
                        ndy = 1;
                        ndx = 0;
                    }
                } else if (i.key.wVirtualKeyCode == 87) {
                    if (dy == 0) {
                        ndy = -1;
                        ndx = 0;
                    }
                }
            }
            GetNumberOfConsoleInputEvents(h, &evt_count);
        }
        dx = ndx;
        dy = ndy;

        Part head;
        head.x = snake[0].x + dx;
        head.y = snake[0].y + dy;

        ix = 1;
        while (ix < len) {
            snake[len - ix] = snake[len - ix - 1];
            ix = ix + 1;
        }
        if (has_snake(snake, len, head.x, head.y)) {
            SetConsoleMode(h, old_mode);
            return 0;
        }
        if (head.x == 0 || head.y == 0 || head.x == 24 || head.y == 24) {
            SetConsoleMode(h, old_mode);
            return 0;
        }
        snake[0] = head;

        if (head.x == ax && head.y == ay) {
            snake[len].x = snake[len - 1].x;
            snake[len].y = snake[len - 1].y;
            len = len + 1;
            randomize_apple(&ax, &ay, snake, len);
        }
        
        output(snake, len, ax, ay);
        Sleep(100);
    }

    return 0;
}
